import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { UserDataHandler } from './user.data.handler';
import { User as DbUser, User } from '@prisma/client';
import * as O from 'fp-ts/Option';
import * as E from 'fp-ts/Either';
import { AuthUser } from 'src/types/AuthUser';
import { USER_NOT_FOUND, USER_UPDATE_FAILED } from 'src/errors';
import { encrypt, stringToJson } from 'src/utils';
import { OffsetPaginationArgs } from 'src/types/input-types.args';

@Injectable()
export class UserService {

    constructor(
        private readonly prisma: PrismaService,
    ) {}


    private userDataHandlers: UserDataHandler[] = [];

    registerUserDataHandler(handler: UserDataHandler) {
      this.userDataHandlers.push(handler);
    }

      /**
   * Converts a prisma user object to a user object
   *
   * @param dbUser Prisma User object
   * @returns  User object
   */
  convertDbUserToUser(dbUser: DbUser) {
    const dbCurrentRESTSession = dbUser.currentRESTSession;
    return {
      ...dbUser,
      currentRESTSession: dbCurrentRESTSession
        ? JSON.stringify(dbCurrentRESTSession)
        : null,
    };
  }

    /**
   * Find User with given email id
   *
   * @param email User's email
   * @returns Option of found User
   */
    async findUserByEmail(email: string): Promise<O.None | O.Some<AuthUser>> {
        const user = await this.prisma.user.findFirst({
          where: {
            email: {
              equals: email,
              mode: 'insensitive',
            },
          },
        });
        if (!user) return O.none;
        return O.some(user);
      }


        /**
   * Find User with given ID
   *
   * @param userId User ID
   * @returns Option of found User
   */
  async findUserById(userId: number): Promise<O.None | O.Some<AuthUser>> {
    try {
      const user = await this.prisma.user.findUniqueOrThrow({
        where: {
          id: userId,
        },
      });
      return O.some(user);
    } catch (error) {
      return O.none;
    }
  }


    /**
   * Update User with new generated hashed refresh token
   *
   * @param refreshTokenHash Hash of newly generated refresh token
   * @param userUid User uid
   * @returns Either of User with updated refreshToken
   */
    async updateUserRefreshToken(refreshTokenHash: string, userId: number) {
        try {
          const user = await this.prisma.user.update({
            where: {
              id: userId,
            },
            data: {
              refreshToken: refreshTokenHash,
            },
          });
    
          return E.right(user);
        } catch (error) {
          return E.left(USER_NOT_FOUND);
        }
      }


  /**
   * Create a new User when logged in via a SSO provider
   *
   * @param accessTokenSSO  User's access token generated by providers
   * @param refreshTokenSSO User's refresh token generated by providers
   * @param profile Data received from SSO provider on the users account
   * @returns Created User
   */
  async createUserSSO(
    accessTokenSSO: string,
    refreshTokenSSO: string,
    profile,
  ) {
    const userDisplayName = !profile.displayName ? null : profile.displayName;
    const userPhotoURL = !profile.photos ? null : profile.photos[0].value;

    const createdUser = await this.prisma.user.create({
      data: {
        displayName: userDisplayName,
        email: profile.emails[0].value,
        photoURL: userPhotoURL,
        lastLoggedOn: new Date(),
        providerAccounts: {
          create: {
            provider: profile.provider,
            providerAccountId: profile.id,
            providerRefreshToken: refreshTokenSSO,
            providerAccessToken: accessTokenSSO,
          },
        },
      },
    });

    // console.log('Created User: ', createdUser);

    return createdUser;
  }


    /**
   * Create a new  Account for a given User
   *
   * @param user User object
   * @param accessToken User's access token generated by providers
   * @param refreshToken User's refresh token generated by providers
   * @param profile Data received from SSO provider on the users account
   * @returns Created Account
   */
    async createProviderAccount(
        user: AuthUser,
        accessToken: string,
        refreshToken: string,
        profile,
      ) {
        const createdProvider = await this.prisma.account.create({
          data: {
            provider: profile.provider,
            providerAccountId: profile.id,
            providerRefreshToken: refreshToken ? encrypt(refreshToken) : null,
            providerAccessToken: accessToken ? encrypt(accessToken) : null,
            user: {
              connect: {
                id: user.id,
              },
            },
          },
        });
    
        return createdProvider;
      }
      


  /**
   * Update User displayName and photoURL when logged in via a SSO provider
   *
   * @param user User object
   * @param profile Data received from SSO provider on the users account
   * @returns Updated user object
   */
  async updateUserDetails(user: AuthUser, profile) {
    try {
      const updatedUser = await this.prisma.user.update({
        where: {
          id: user.id,
        },
        data: {
          displayName: !profile.displayName ? null : profile.displayName,
          photoURL: !profile.photos ? null : profile.photos[0].value,
          lastLoggedOn: new Date(),
        },
      });
      return E.right(updatedUser);
    } catch (error) {
      return E.left(USER_NOT_FOUND);
    }
  }


    /**
   * Update a user's sessions
   * @param user User object
   * @param currentRESTSession user's current REST session
   * @param currentGQLSession user's current GQL session
   * @returns a Either of User or error
   */
    async updateUserSessions(
        user: AuthUser,
        currentSession: string,
        sessionType: string,
      ): Promise<E.Right<User> | E.Left<string>> {
        const validatedSession = await this.validateSession(currentSession);
        if (E.isLeft(validatedSession)) return E.left(validatedSession.left);
    
        try {
          const sessionObj = {};
          switch (sessionType) {
            case 'REST':
              sessionObj['currentRESTSession'] = validatedSession.right;
              break;
            default:
              return E.left(USER_UPDATE_FAILED);
          }
    
          const dbUpdatedUser = await this.prisma.user.update({
            where: { id: user.id },
            data: sessionObj,
          });
    
          const updatedUser = this.convertDbUserToUser(dbUpdatedUser);
    
          return E.right(updatedUser);
        } catch (e) {
          return E.left(USER_UPDATE_FAILED);
        }
      }


    /**
   * Validate and parse currentRESTSession and currentGQLSession
   * @param sessionData string of the session
   * @returns a Either of JSON object or error
   */
    async validateSession(sessionData: string) {
        const jsonSession = stringToJson(sessionData);
        if (E.isLeft(jsonSession)) return E.left(jsonSession.left);
    
        return E.right(jsonSession.right);
    }
    
    /**
   * Update user's lastLoggedOn timestamp
   * @param userID User ID
   */
  async updateUserLastLoggedOn(userId: number) {
    try {
      await this.prisma.user.update({
        where: { id: userId },
        data: { lastLoggedOn: new Date() },
      });
      return E.right(true);
    } catch (e) {
      return E.left(USER_NOT_FOUND);
    }
  }


  /**
   * Fetch all the users in the `User` table based on cursor
   * @param searchString search on user's displayName or email
   * @param paginationOption pagination options
   * @returns an array of `User` object
   */
  async fetchAllUsers(
    searchString: string,
    paginationOption: OffsetPaginationArgs,
  ) {
    const fetchedUsers = await this.prisma.user.findMany({
      skip: paginationOption.skip,
      take: paginationOption.take,
      where: searchString
        ? {
            OR: [
              {
                displayName: {
                  contains: searchString,
                  mode: 'insensitive',
                },
              },
              {
                email: {
                  contains: searchString,
                  mode: 'insensitive',
                },
              },
            ],
          }
        : undefined,
      orderBy: [{ displayName: 'asc' }],
    });

    return fetchedUsers;
  }


    /**
   * Fetch the number of users in db
   * @returns a count (Int) of user records in DB
   */
    async getUsersCount() {
        const usersCount = await this.prisma.user.count();
        return usersCount;
  }


      /**
   * Deletes a user account by id
   * @param id User ID
   * @returns an Either of string  or boolean
   */
  async deleteUserAccount(id: number) {
    try {
      await this.prisma.user.delete({
        where: {
          id: id,
        },
      });
      return E.right(true);
    } catch (e) {
      return E.left(USER_NOT_FOUND);
    }
  }



}
